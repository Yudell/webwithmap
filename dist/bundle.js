/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./map-data.js":
/*!*********************!*\
  !*** ./map-data.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GENERATION_SCALE_STEP: () => (/* binding */ GENERATION_SCALE_STEP),\n/* harmony export */   MAX_GENERATION_SCALE: () => (/* binding */ MAX_GENERATION_SCALE),\n/* harmony export */   MIN_GENERATION_SCALE: () => (/* binding */ MIN_GENERATION_SCALE),\n/* harmony export */   generateNewPhysmapData: () => (/* binding */ generateNewPhysmapData),\n/* harmony export */   getCellSize: () => (/* binding */ getCellSize),\n/* harmony export */   getGenerationScale: () => (/* binding */ getGenerationScale),\n/* harmony export */   getPhysmap: () => (/* binding */ getPhysmap),\n/* harmony export */   setGenerationScale: () => (/* binding */ setGenerationScale),\n/* harmony export */   terrainType: () => (/* binding */ terrainType)\n/* harmony export */ });\n/* harmony import */ var _mapgen_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mapgen.js */ \"./mapgen.js\");\n\r\n\r\nconst terrainType = {\r\n  OCEAN: 'OCEAN',\r\n  SEA: 'SEA',\r\n  WET_SAND: 'WET_SAND',\r\n  SAND: 'SAND',\r\n  DRY_SAND: 'DRY_SAND',\r\n  DRY_GRASS: 'DRY_GRASS',\r\n  GRASS: 'GRASS',\r\n  WET_GRASS: 'WET_GRASS',\r\n  MOUNTAIN_SNOW: 'MOUNTAIN_SNOW',\r\n  MOUNTAIN_ORE: 'MOUNTAIN_ORE',\r\n  MOUNTAIN: 'MOUNTAIN',\r\n  FOREST: 'FOREST'\r\n};\r\n\r\nlet physmap = null;\r\nlet cellSize = 3; // Default, will be calculated\r\n\r\n// --- Параметры генерационного зума ---\r\nlet currentGenerationScale = 1;\r\nconst MIN_GENERATION_SCALE = 0.5;\r\nconst MAX_GENERATION_SCALE = 5;\r\nconst GENERATION_SCALE_STEP = 0.5;\r\n\r\nfunction calculateCellSizeForGenerationInternal() {\r\n  const screenWidth = window.innerWidth;\r\n  const screenHeight = window.innerHeight;\r\n  const baseSize = Math.max(2, Math.min(4,\r\n    Math.floor(Math.min(screenWidth, screenHeight) / 250)));\r\n  return baseSize / currentGenerationScale;\r\n}\r\n\r\nfunction getMapDataDimensionsInternal() {\r\n  return {\r\n    width: Math.floor(window.innerWidth / cellSize),\r\n    height: Math.floor(window.innerHeight / cellSize)\r\n  };\r\n}\r\n\r\nfunction initializeNoiseGenerators() {\r\n  const seeds = {\r\n    terrain: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.generateRandomSeed)(), variant: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.generateRandomSeed)(), biome: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.generateRandomSeed)(),\r\n    detail: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.generateRandomSeed)(), sand: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.generateRandomSeed)(), mountain1: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.generateRandomSeed)(),\r\n    mountain2: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.generateRandomSeed)()\r\n  };\r\n  const sandNoise = (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.newFractalNoise)({ noise: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.createNoise)(seeds.sand), octaves: 10, frequency: 0.1, persistence: 0.01 });\r\n  return {\r\n    terrainNoise: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.newFractalNoise)({ noise: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.createNoise)(seeds.terrain), octaves: _mapgen_js__WEBPACK_IMPORTED_MODULE_0__.defaultOctaves, frequency: _mapgen_js__WEBPACK_IMPORTED_MODULE_0__.defaultFrequency, persistence: _mapgen_js__WEBPACK_IMPORTED_MODULE_0__.defaultPersistence }),\r\n    variantNoise: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.newFractalNoise)({ noise: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.createNoise)(seeds.variant), octaves: _mapgen_js__WEBPACK_IMPORTED_MODULE_0__.defaultOctaves, frequency: _mapgen_js__WEBPACK_IMPORTED_MODULE_0__.defaultFrequency, persistence: _mapgen_js__WEBPACK_IMPORTED_MODULE_0__.defaultPersistence }),\r\n    detailNoise: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.newFractalNoise)({ noise: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.createNoise)(seeds.detail), octaves: 6, frequency: 0.6, persistence: 0.7 }),\r\n    mountainNoise1: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.newFractalNoise)({ noise: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.createNoise)(seeds.mountain1), octaves: _mapgen_js__WEBPACK_IMPORTED_MODULE_0__.defaultOctaves, frequency: _mapgen_js__WEBPACK_IMPORTED_MODULE_0__.defaultFrequency, persistence: _mapgen_js__WEBPACK_IMPORTED_MODULE_0__.defaultPersistence }),\r\n    mountainNoise2: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.newFractalNoise)({ noise: (0,_mapgen_js__WEBPACK_IMPORTED_MODULE_0__.createNoise)(seeds.mountain2), octaves: _mapgen_js__WEBPACK_IMPORTED_MODULE_0__.defaultOctaves, frequency: _mapgen_js__WEBPACK_IMPORTED_MODULE_0__.defaultFrequency, persistence: _mapgen_js__WEBPACK_IMPORTED_MODULE_0__.defaultPersistence }),\r\n    sandNoise\r\n  };\r\n}\r\n\r\nfunction generateNewPhysmapData() {\r\n  cellSize = calculateCellSizeForGenerationInternal();\r\n  const { width, height } = getMapDataDimensionsInternal();\r\n  const noise = initializeNoiseGenerators();\r\n  const newMap = [];\r\n  for (let y = 0; y < height; y++) {\r\n    newMap[y] = [];\r\n    for (let x = 0; x < width; x++) {\r\n      const terrainValue = noise.terrainNoise(x/100, y/100) + noise.detailNoise(x/20, y/20) * 0.15;\r\n      const variantValue = noise.variantNoise(x/100, y/100);\r\n      const sandValue = noise.sandNoise(x/50, y/50);\r\n      const localSandThreshold = 0.22 + sandValue * 0.01;\r\n      const isMountain = Math.max(noise.mountainNoise1(x/100, y/100), noise.mountainNoise2(x/100, y/100)) > 0.5;\r\n      let info = {};\r\n      if (terrainValue < 0) { info.color = '#003eb2'; info.type = terrainType.OCEAN; }\r\n      else if (terrainValue < 0.2) { info.color = '#0952c6'; info.type = terrainType.SEA; }\r\n      else if (terrainValue < localSandThreshold) {\r\n        info.variantNoise = variantValue;\r\n        if (variantValue < -0.2) { info.color = '#867645'; info.type = terrainType.WET_SAND; }\r\n        else if (variantValue < 0.2) { info.color = '#a49463'; info.type = terrainType.SAND; }\r\n        else { info.color = '#c2b281'; info.type = terrainType.DRY_SAND; }\r\n      } else if (isMountain && terrainValue > 0.3) {\r\n        info.variantNoise = variantValue;\r\n        if (variantValue < -0.2) { info.color = '#ebebeb'; info.type = terrainType.MOUNTAIN_SNOW; }\r\n        else if (variantValue < 0.2) { info.color = '#8c8e7b'; info.type = terrainType.MOUNTAIN_ORE; }\r\n        else { info.color = '#a0a28f'; info.type = terrainType.MOUNTAIN; }\r\n      } else if (terrainValue < 0.5) {\r\n        info.variantNoise = variantValue;\r\n        if (variantValue < -0.2) { info.color = '#284d00'; info.type = terrainType.DRY_GRASS; }\r\n        else if (variantValue < 0.2) { info.color = '#3c6114'; info.type = terrainType.GRASS; }\r\n        else { info.color = '#5a7f32'; info.type = terrainType.WET_GRASS; }\r\n      } else { info.color = '#8c8e7b'; info.type = 'HILLS'; } // TODO: Define HILLS in terrainType\r\n      if (info.type === terrainType.GRASS && noise.detailNoise(x/10, y/10) > 0.7) {\r\n        info.type = terrainType.FOREST; info.color = '#2d5a27';\r\n      }\r\n      newMap[y][x] = info;\r\n    }\r\n  }\r\n  physmap = newMap;\r\n  // View parameters (viewScale, viewTranslateX/Y) and clampViewTranslate()\r\n  // are handled by the UI/view module after this function is called.\r\n}\r\n\r\nfunction getPhysmap() {\r\n  return physmap;\r\n}\r\n\r\nfunction getCellSize() {\r\n  return cellSize;\r\n}\r\n\r\nfunction getGenerationScale() {\r\n  return currentGenerationScale;\r\n}\r\n\r\nfunction setGenerationScale(newScale) {\r\n  currentGenerationScale = Math.max(MIN_GENERATION_SCALE, Math.min(MAX_GENERATION_SCALE, newScale));\r\n  // Note: cellSize will be recalculated when generateNewPhysmapData is called.\r\n}\n\n//# sourceURL=webpack:///./map-data.js?");

/***/ }),

/***/ "./map-view.js":
/*!*********************!*\
  !*** ./map-view.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _map_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map-data.js */ \"./map-data.js\");\n\r\n\r\nlet resizeTimeout;\r\n\r\n// --- Параметры оптического зума и панорамирования вида ---\r\nlet viewScale = 1.0;\r\nconst MIN_VIEW_SCALE = 1;\r\nconst MAX_VIEW_SCALE = 10.0;\r\nconst VIEW_SCALE_SENSITIVITY = 0.001;\r\n\r\nlet viewTranslateX = 0;\r\nlet viewTranslateY = 0;\r\n\r\nlet isPanning = false;\r\nlet lastPanX, lastPanY;\r\n\r\nconst canvas = document.getElementById('map-canvas');\r\nlet ctx = null; // Контекст будет инициализирован в DOMContentLoaded\r\nlet needsRedraw = false; // Флаг для requestAnimationFrame\r\n\r\nfunction updateGenerationScaleDisplay() {\r\n  document.getElementById('scale-display').textContent =\r\n    `${Math.round((0,_map_data_js__WEBPACK_IMPORTED_MODULE_0__.getGenerationScale)() * 100)}%`;\r\n}\r\n\r\nfunction clampViewTranslate() {\r\n    const currentPhysmap = (0,_map_data_js__WEBPACK_IMPORTED_MODULE_0__.getPhysmap)();\r\n    const currentCellSize = (0,_map_data_js__WEBPACK_IMPORTED_MODULE_0__.getCellSize)();\r\n\r\n    if (!currentPhysmap || !currentPhysmap.length || !currentPhysmap[0] || !currentPhysmap[0].length) return;\r\n\r\n    const viewportWidth = window.innerWidth;\r\n    const viewportHeight = window.innerHeight;\r\n\r\n    const mapTotalWorldWidth = currentPhysmap[0].length * currentCellSize;\r\n    const mapTotalWorldHeight = currentPhysmap.length * currentCellSize;\r\n\r\n    const scaledMapWidth = mapTotalWorldWidth * viewScale;\r\n    const scaledMapHeight = mapTotalWorldHeight * viewScale;\r\n\r\n    if (scaledMapWidth < viewportWidth) {\r\n        viewTranslateX = Math.max(0, Math.min(viewTranslateX, viewportWidth - scaledMapWidth));\r\n    } else {\r\n        viewTranslateX = Math.max(viewportWidth - scaledMapWidth, Math.min(viewTranslateX, 0));\r\n    }\r\n\r\n    if (scaledMapHeight < viewportHeight) {\r\n        viewTranslateY = Math.max(0, Math.min(viewTranslateY, viewportHeight - scaledMapHeight));\r\n    } else {\r\n        viewTranslateY = Math.max(viewportHeight - scaledMapHeight, Math.min(viewTranslateY, 0));\r\n    }\r\n}\r\n\r\nfunction requestRedraw() {\r\n  needsRedraw = true;\r\n}\r\n\r\nfunction updateCanvasSize() {\r\n    if (!ctx) return;\r\n    const deviceRatio = window.devicePixelRatio || 1;\r\n    const newWidth = window.innerWidth * deviceRatio;\r\n    const newHeight = window.innerHeight * deviceRatio;\r\n\r\n    if (canvas.width !== newWidth || canvas.height !== newHeight) {\r\n        canvas.width = newWidth;\r\n        canvas.height = newHeight;\r\n        canvas.style.width = `${window.innerWidth}px`;\r\n        canvas.style.height = `${window.innerHeight}px`;\r\n        requestRedraw();\r\n    }\r\n}\r\n\r\nfunction drawMapInternal() {\r\n  const currentPhysmap = (0,_map_data_js__WEBPACK_IMPORTED_MODULE_0__.getPhysmap)();\r\n  const currentCellSize = (0,_map_data_js__WEBPACK_IMPORTED_MODULE_0__.getCellSize)();\r\n\r\n  if (!currentPhysmap || !currentPhysmap[0] || !currentPhysmap[0].length || !ctx) return;\r\n\r\n  const deviceRatio = window.devicePixelRatio || 1;\r\n\r\n  ctx.setTransform(deviceRatio, 0, 0, deviceRatio, 0, 0);\r\n  ctx.imageSmoothingEnabled = false;\r\n  ctx.save();\r\n  ctx.clearRect(0, 0, canvas.width / deviceRatio, canvas.height / deviceRatio);\r\n  ctx.translate(viewTranslateX, viewTranslateY);\r\n  ctx.scale(viewScale, viewScale);\r\n\r\n  const mapDataHeight = currentPhysmap.length;\r\n  const mapDataWidth = currentPhysmap[0].length;\r\n  const singleDevicePixelInWorldUnits = 1.0 / (viewScale * deviceRatio);\r\n\r\n  const worldViewX1 = (0 - viewTranslateX) / viewScale;\r\n  const worldViewY1 = (0 - viewTranslateY) / viewScale;\r\n  const worldViewX2 = (window.innerWidth - viewTranslateX) / viewScale;\r\n  const worldViewY2 = (window.innerHeight - viewTranslateY) / viewScale;\r\n\r\n  const cullingMargin = 2;\r\n  let startX = Math.max(0, Math.floor(worldViewX1 / currentCellSize) - cullingMargin);\r\n  let startY = Math.max(0, Math.floor(worldViewY1 / currentCellSize) - cullingMargin);\r\n  let endX = Math.min(mapDataWidth, Math.ceil(worldViewX2 / currentCellSize) + cullingMargin);\r\n  let endY = Math.min(mapDataHeight, Math.ceil(worldViewY2 / currentCellSize) + cullingMargin);\r\n\r\n  for (let y = startY; y < endY; y++) {\r\n    for (let x = startX; x < endX; x++) {\r\n      if (currentPhysmap[y] && currentPhysmap[y][x]) {\r\n        ctx.fillStyle = currentPhysmap[y][x].color;\r\n        const cellWorldX = x * currentCellSize;\r\n        const cellWorldY = y * currentCellSize;\r\n        const cellDrawingWidth = currentCellSize + singleDevicePixelInWorldUnits;\r\n        const cellDrawingHeight = currentCellSize + singleDevicePixelInWorldUnits;\r\n        ctx.fillRect(cellWorldX, cellWorldY, cellDrawingWidth, cellDrawingHeight);\r\n      }\r\n    }\r\n  }\r\n  ctx.restore();\r\n}\r\n\r\nfunction renderLoop() {\r\n  updateCanvasSize();\r\n  if (needsRedraw) {\r\n    drawMapInternal();\r\n    needsRedraw = false;\r\n  }\r\n  requestAnimationFrame(renderLoop);\r\n}\r\n\r\nfunction regenerateMapAndView() {\r\n    (0,_map_data_js__WEBPACK_IMPORTED_MODULE_0__.generateNewPhysmapData)();\r\n    viewScale = 1.0;\r\n    viewTranslateX = 0;\r\n    viewTranslateY = 0;\r\n    clampViewTranslate();\r\n    requestRedraw();\r\n    updateGenerationScaleDisplay();\r\n}\r\n\r\nfunction handleGenerationZoomIn() {\r\n  const currentGenScale = (0,_map_data_js__WEBPACK_IMPORTED_MODULE_0__.getGenerationScale)();\r\n  if (currentGenScale < _map_data_js__WEBPACK_IMPORTED_MODULE_0__.MAX_GENERATION_SCALE) {\r\n    (0,_map_data_js__WEBPACK_IMPORTED_MODULE_0__.setGenerationScale)(currentGenScale + _map_data_js__WEBPACK_IMPORTED_MODULE_0__.GENERATION_SCALE_STEP);\r\n    regenerateMapAndView();\r\n  }\r\n}\r\n\r\nfunction handleGenerationZoomOut() {\r\n  const currentGenScale = (0,_map_data_js__WEBPACK_IMPORTED_MODULE_0__.getGenerationScale)();\r\n  if (currentGenScale > _map_data_js__WEBPACK_IMPORTED_MODULE_0__.MIN_GENERATION_SCALE) {\r\n    (0,_map_data_js__WEBPACK_IMPORTED_MODULE_0__.setGenerationScale)(currentGenScale - _map_data_js__WEBPACK_IMPORTED_MODULE_0__.GENERATION_SCALE_STEP);\r\n    regenerateMapAndView();\r\n  }\r\n}\r\n\r\nfunction handleViewZoom(event) {\r\n  event.preventDefault();\r\n  const rect = canvas.getBoundingClientRect();\r\n  const mouseX = event.clientX - rect.left;\r\n  const mouseY = event.clientY - rect.top;\r\n  const worldXBeforeZoom = (mouseX - viewTranslateX) / viewScale;\r\n  const worldYBeforeZoom = (mouseY - viewTranslateY) / viewScale;\r\n  const delta = event.deltaY * VIEW_SCALE_SENSITIVITY * -1;\r\n  let newViewScale = viewScale * Math.exp(delta);\r\n  newViewScale = Math.max(MIN_VIEW_SCALE, Math.min(MAX_VIEW_SCALE, newViewScale));\r\n  viewTranslateX = mouseX - worldXBeforeZoom * newViewScale;\r\n  viewTranslateY = mouseY - worldYBeforeZoom * newViewScale;\r\n  viewScale = newViewScale;\r\n  clampViewTranslate();\r\n  requestRedraw();\r\n}\r\n\r\nfunction handlePanStart(event) {\r\n  if (event.button !== 0) return;\r\n  isPanning = true;\r\n  lastPanX = event.clientX;\r\n  lastPanY = event.clientY;\r\n  canvas.style.cursor = 'grabbing';\r\n}\r\n\r\nfunction handlePanMove(event) {\r\n  if (!isPanning) return;\r\n  const dx = event.clientX - lastPanX;\r\n  const dy = event.clientY - lastPanY;\r\n  viewTranslateX += dx;\r\n  viewTranslateY += dy;\r\n  lastPanX = event.clientX;\r\n  lastPanY = event.clientY;\r\n  clampViewTranslate();\r\n  requestRedraw();\r\n}\r\n\r\nfunction handlePanEnd(event) {\r\n  if (isPanning && event.button === 0) {\r\n     isPanning = false;\r\n     canvas.style.cursor = 'grab';\r\n  } else if (event.button !==0 && isPanning) {\r\n    canvas.style.cursor = 'grab';\r\n  }\r\n}\r\n\r\nfunction handleMouseLeaveCanvas() {\r\n  if (isPanning) {\r\n    // isPanning will be reset by window mouseup\r\n  }\r\n  if (!isPanning) { // Ensure cursor is reset if panning stopped for other reasons\r\n      canvas.style.cursor = 'grab';\r\n  }\r\n}\r\n\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  ctx = canvas.getContext('2d');\r\n  if (!ctx) {\r\n    console.error(\"Не удалось получить 2D контекст для canvas.\");\r\n    return;\r\n  }\r\n  canvas.style.cursor = 'grab';\r\n\r\n  (0,_map_data_js__WEBPACK_IMPORTED_MODULE_0__.setGenerationScale)(1.0); // Initialize generation scale\r\n  regenerateMapAndView(); // Generates map and sets up initial view\r\n\r\n  requestAnimationFrame(renderLoop);\r\n\r\n  window.addEventListener('resize', () => {\r\n    clearTimeout(resizeTimeout);\r\n    resizeTimeout = setTimeout(() => {\r\n      // Generation scale is preserved\r\n      regenerateMapAndView();\r\n    }, 250);\r\n  });\r\n\r\n  document.getElementById('generate-map').addEventListener('click', () => {\r\n    // Uses current generation scale. If reset to 100% is desired:\r\n    // setGenerationScale(1.0);\r\n    regenerateMapAndView();\r\n  });\r\n\r\n  document.getElementById('download-map').addEventListener('click', () => {\r\n    const currentPhysmap = (0,_map_data_js__WEBPACK_IMPORTED_MODULE_0__.getPhysmap)();\r\n    if (!currentPhysmap) { alert(\"Сначала сгенерируйте карту!\"); return; }\r\n    const tempCanvas = document.createElement('canvas');\r\n    const tempCtx = tempCanvas.getContext('2d');\r\n    const mapDataHeight = currentPhysmap.length;\r\n    const mapDataWidth = currentPhysmap[0].length;\r\n    const downloadCellPixelSize = 3;\r\n    tempCanvas.width = mapDataWidth * downloadCellPixelSize;\r\n    tempCanvas.height = mapDataHeight * downloadCellPixelSize;\r\n    tempCtx.imageSmoothingEnabled = false;\r\n    for (let y = 0; y < mapDataHeight; y++) {\r\n      for (let x = 0; x < mapDataWidth; x++) {\r\n        if (currentPhysmap[y] && currentPhysmap[y][x]) {\r\n          const info = currentPhysmap[y][x];\r\n          tempCtx.fillStyle = info.color;\r\n          tempCtx.fillRect(x*downloadCellPixelSize, y*downloadCellPixelSize, downloadCellPixelSize, downloadCellPixelSize);\r\n        }\r\n      }\r\n    }\r\n    const link = document.createElement('a');\r\n    link.download = 'fantasy-map.png';\r\n    link.href = tempCanvas.toDataURL('image/png');\r\n    link.click();\r\n  });\r\n\r\n  document.getElementById('zoom-in').addEventListener('click', handleGenerationZoomIn);\r\n  document.getElementById('zoom-out').addEventListener('click', handleGenerationZoomOut);\r\n\r\n  canvas.addEventListener('wheel', handleViewZoom, { passive: false });\r\n  canvas.addEventListener('mousedown', handlePanStart);\r\n  window.addEventListener('mousemove', handlePanMove);\r\n  window.addEventListener('mouseup', handlePanEnd);\r\n  canvas.addEventListener('mouseleave', handleMouseLeaveCanvas);\r\n\r\n  document.addEventListener('wheel', (e) => {\r\n    if (e.ctrlKey) {\r\n      e.preventDefault();\r\n      if (e.deltaY < 0) handleGenerationZoomIn();\r\n      else handleGenerationZoomOut();\r\n    }\r\n  }, { passive: false });\r\n});\n\n//# sourceURL=webpack:///./map-view.js?");

/***/ }),

/***/ "./mapgen.js":
/*!*******************!*\
  !*** ./mapgen.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNoise: () => (/* binding */ createNoise),\n/* harmony export */   defaultFrequency: () => (/* binding */ defaultFrequency),\n/* harmony export */   defaultOctaves: () => (/* binding */ defaultOctaves),\n/* harmony export */   defaultPersistence: () => (/* binding */ defaultPersistence),\n/* harmony export */   generateRandomSeed: () => (/* binding */ generateRandomSeed),\n/* harmony export */   newFractalNoise: () => (/* binding */ newFractalNoise)\n/* harmony export */ });\n/* harmony import */ var open_simplex_noise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! open-simplex-noise */ \"./node_modules/open-simplex-noise/lib/2d.js\");\n\r\n\r\nfunction generateRandomSeed() {\r\n  return Math.floor(Math.random() * Math.pow(2, 32));\r\n}\r\n\r\nfunction createNoise(seed) {\r\n  return (0,open_simplex_noise__WEBPACK_IMPORTED_MODULE_0__.makeNoise2D)(seed);\r\n}\r\n\r\nfunction newFractalNoise(info) {\r\n  const {\r\n    noise,\r\n    octaves = defaultOctaves,\r\n    amplitude = 1,\r\n    frequency = defaultFrequency,\r\n    persistence = defaultPersistence,\r\n    stretchX = 1.0,\r\n    stretchY = 1.0 \r\n  } = info;\r\n\r\n  return function getFractalNoise(x, y) {\r\n    let value = 0.0;\r\n\r\n    for (let octave = 0; octave < octaves; octave++) {\r\n      let freq = frequency * Math.pow(2, octave);\r\n\r\n      const nx = x * freq * stretchX;\r\n      const ny = y * freq * stretchY;\r\n      value += noise(nx, ny) * (amplitude * Math.pow(persistence, octave));\r\n    }\r\n\r\n    return value / (2 - 1 / Math.pow(2, octaves - 1));\r\n  };\r\n}\r\n\r\nconst defaultOctaves = 11;\r\nconst defaultFrequency = 0.2;\r\nconst defaultPersistence = 0.65;\r\n\r\n\n\n//# sourceURL=webpack:///./mapgen.js?");

/***/ }),

/***/ "./node_modules/open-simplex-noise/lib/2d.js":
/*!***************************************************!*\
  !*** ./node_modules/open-simplex-noise/lib/2d.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\n// This is free and unencumbered software released into the public domain\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.makeNoise2D = void 0;\r\nvar shuffle_seed_1 = __webpack_require__(/*! ./shuffle_seed */ \"./node_modules/open-simplex-noise/lib/shuffle_seed.js\");\r\nvar NORM_2D = 1.0 / 47.0;\r\nvar SQUISH_2D = (Math.sqrt(2 + 1) - 1) / 2;\r\nvar STRETCH_2D = (1 / Math.sqrt(2 + 1) - 1) / 2;\r\nfunction contribution2D(multiplier, xsb, ysb) {\r\n    return {\r\n        dx: -xsb - multiplier * SQUISH_2D,\r\n        dy: -ysb - multiplier * SQUISH_2D,\r\n        xsb: xsb,\r\n        ysb: ysb,\r\n    };\r\n}\r\nfunction makeNoise2D(clientSeed) {\r\n    var contributions = [];\r\n    for (var i = 0; i < p2D.length; i += 4) {\r\n        var baseSet = base2D[p2D[i]];\r\n        var previous = null;\r\n        var current = null;\r\n        for (var k = 0; k < baseSet.length; k += 3) {\r\n            current = contribution2D(baseSet[k], baseSet[k + 1], baseSet[k + 2]);\r\n            if (previous === null)\r\n                contributions[i / 4] = current;\r\n            else\r\n                previous.next = current;\r\n            previous = current;\r\n        }\r\n        current.next = contribution2D(p2D[i + 1], p2D[i + 2], p2D[i + 3]);\r\n    }\r\n    var lookup = [];\r\n    for (var i = 0; i < lookupPairs2D.length; i += 2) {\r\n        lookup[lookupPairs2D[i]] = contributions[lookupPairs2D[i + 1]];\r\n    }\r\n    var perm = new Uint8Array(256);\r\n    var perm2D = new Uint8Array(256);\r\n    var source = new Uint8Array(256);\r\n    for (var i = 0; i < 256; i++)\r\n        source[i] = i;\r\n    var seed = new Uint32Array(1);\r\n    seed[0] = clientSeed;\r\n    seed = shuffle_seed_1.default(shuffle_seed_1.default(shuffle_seed_1.default(seed)));\r\n    for (var i = 255; i >= 0; i--) {\r\n        seed = shuffle_seed_1.default(seed);\r\n        var r = new Uint32Array(1);\r\n        r[0] = (seed[0] + 31) % (i + 1);\r\n        if (r[0] < 0)\r\n            r[0] += i + 1;\r\n        perm[i] = source[r[0]];\r\n        perm2D[i] = perm[i] & 0x0e;\r\n        source[r[0]] = source[i];\r\n    }\r\n    return function (x, y) {\r\n        var stretchOffset = (x + y) * STRETCH_2D;\r\n        var xs = x + stretchOffset;\r\n        var ys = y + stretchOffset;\r\n        var xsb = Math.floor(xs);\r\n        var ysb = Math.floor(ys);\r\n        var squishOffset = (xsb + ysb) * SQUISH_2D;\r\n        var dx0 = x - (xsb + squishOffset);\r\n        var dy0 = y - (ysb + squishOffset);\r\n        var xins = xs - xsb;\r\n        var yins = ys - ysb;\r\n        var inSum = xins + yins;\r\n        var hash = (xins - yins + 1) |\r\n            (inSum << 1) |\r\n            ((inSum + yins) << 2) |\r\n            ((inSum + xins) << 4);\r\n        var value = 0;\r\n        for (var c = lookup[hash]; c !== undefined; c = c.next) {\r\n            var dx = dx0 + c.dx;\r\n            var dy = dy0 + c.dy;\r\n            var attn = 2 - dx * dx - dy * dy;\r\n            if (attn > 0) {\r\n                var px = xsb + c.xsb;\r\n                var py = ysb + c.ysb;\r\n                var indexPartA = perm[px & 0xff];\r\n                var index = perm2D[(indexPartA + py) & 0xff];\r\n                var valuePart = gradients2D[index] * dx + gradients2D[index + 1] * dy;\r\n                value += attn * attn * attn * attn * valuePart;\r\n            }\r\n        }\r\n        return value * NORM_2D;\r\n    };\r\n}\r\nexports.makeNoise2D = makeNoise2D;\r\nvar base2D = [\r\n    [1, 1, 0, 1, 0, 1, 0, 0, 0],\r\n    [1, 1, 0, 1, 0, 1, 2, 1, 1],\r\n];\r\nvar gradients2D = [\r\n    5,\r\n    2,\r\n    2,\r\n    5,\r\n    -5,\r\n    2,\r\n    -2,\r\n    5,\r\n    5,\r\n    -2,\r\n    2,\r\n    -5,\r\n    -5,\r\n    -2,\r\n    -2,\r\n    -5,\r\n];\r\nvar lookupPairs2D = [\r\n    0,\r\n    1,\r\n    1,\r\n    0,\r\n    4,\r\n    1,\r\n    17,\r\n    0,\r\n    20,\r\n    2,\r\n    21,\r\n    2,\r\n    22,\r\n    5,\r\n    23,\r\n    5,\r\n    26,\r\n    4,\r\n    39,\r\n    3,\r\n    42,\r\n    4,\r\n    43,\r\n    3,\r\n];\r\nvar p2D = [\r\n    0,\r\n    0,\r\n    1,\r\n    -1,\r\n    0,\r\n    0,\r\n    -1,\r\n    1,\r\n    0,\r\n    2,\r\n    1,\r\n    1,\r\n    1,\r\n    2,\r\n    2,\r\n    0,\r\n    1,\r\n    2,\r\n    0,\r\n    2,\r\n    1,\r\n    0,\r\n    0,\r\n    0,\r\n];\r\n\n\n//# sourceURL=webpack:///./node_modules/open-simplex-noise/lib/2d.js?");

/***/ }),

/***/ "./node_modules/open-simplex-noise/lib/shuffle_seed.js":
/*!*************************************************************!*\
  !*** ./node_modules/open-simplex-noise/lib/shuffle_seed.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\n// This is free and unencumbered software released into the public domain\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nfunction shuffleSeed(seed) {\r\n    var newSeed = new Uint32Array(1);\r\n    newSeed[0] = seed[0] * 1664525 + 1013904223;\r\n    return newSeed;\r\n}\r\nexports[\"default\"] = shuffleSeed;\r\n\n\n//# sourceURL=webpack:///./node_modules/open-simplex-noise/lib/shuffle_seed.js?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./map-view.js");
/******/ 
